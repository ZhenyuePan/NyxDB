# Benchmark: In-memory index structures under high concurrency
# Command: go test ./internal/layers/engine/index -bench BenchmarkIndex -benchmem -run ^$
# Platform: linux/amd64, Intel(R) Core(TM) i7-14700
BenchmarkIndexPutBTree-8       5021832   249.4 ns/op   120 B/op   3 allocs/op
BenchmarkIndexPutSkipList-8    3515638   372.1 ns/op   192 B/op   6 allocs/op
BenchmarkIndexPutART-8         9980414   148.9 ns/op   116 B/op   5 allocs/op
BenchmarkIndexPutSharded-8     6210234   224.7 ns/op   120 B/op   3 allocs/op
BenchmarkIndexGetBTree-8      29703358    42.11 ns/op   36 B/op   2 allocs/op
BenchmarkIndexGetSkipList-8   31637409    42.26 ns/op   28 B/op   2 allocs/op
BenchmarkIndexGetART-8        32680914    35.01 ns/op    4 B/op   1 allocs/op
BenchmarkIndexGetSharded-8    27600142    44.78 ns/op   36 B/op   2 allocs/op

高并发写入

ART (148.9 ns/op)：吞吐最佳；基于压缩前缀的树结构，定位路径短、节点竞争小，天然适合随机高并发写。但内存占用略高（节点指针+元数据），实现复杂。
Sharded BTree (224.7 ns/op)：通过范围路由把热点分散到多棵 BTree，写延迟约比单 BTree 快 10%；适合既要维持范围顺序，又希望降低单树锁竞争的场景。

单 BTree (249.4 ns/op)：性能居中，胜在实现稳健、空间紧凑，缺点是全局锁导致写高并发下吞吐受限。
SkipList (372.1 ns/op)：写入最慢；即便修正了锁范围，链表层级内仍需多次 hop，且内存分配频繁；优势是实现简单，能自然支持范围遍历。
高并发读取

ART (35.01 ns/op)：访问路径最短，几乎无额外分配，是读取场景的性能王者。
SkipList & BTree (~42 ns/op)：读性能相近，skiplist 在读场景的路径较短，不需要重排，表现可靠；BTree 的指针跳转稍多，但也很稳定。
Sharded BTree (44.78 ns/op)：多了一次路由开销 + shard 迭代合并，批量遍历时还需跨 shard；若读多写少，可以考虑把 shard 数调低或转向 ART。

适用建议
追求极致性能：ART 优先；注意压缩键空间与内存占用。
写热点/范围场景：Sharded BTree 在保持顺序的同时能削弱热点，适合作为默认索引。
实现/兼容优先：单 BTree 简洁且读性能不错，适合对并发写要求不高的模块。
轻量可遍历：SkipList 结构简单，范围迭代成本稳定，可用于元数据或辅助索引，但需要接受写入吞吐偏低。
可以依据业务负载（写热点 vs 读占优 vs 范围扫描）选择默认索引类型；也可为不同 Region/表设置不同索引策略，并结合动态统计调整 shard 数或索引实现。

建议保持 Sharded BTree 作为默认索引类型。
理由：
读写性能均衡：写入比单棵 BTree 快约 10%，读取只比最佳的 ART 慢 ~3ns，但无需承担 ART 的额外内存开销与更复杂的实现。
天然范围有序：按范围路由可以稳定地支持区间遍历 / Scan，且能把热点摊在多个 shard 上，适合混合读写负载。
内存占用可控：BTree 节点结构紧凑，整体占用更可预测；ART 虽然最快，但每个节点额外指针较多，对热点键空间更“胖”。
维护与回归成本低：现有代码和测试都围绕 BTree 体系，切换默认索引不会引入额外复杂度；需要更极致性能的业务可以在配置中选择 ART。
总结：Sharded BTree 的折中性最好，适合作为默认；特定场景（低内存敏感、写极热）再按需改用 ART。